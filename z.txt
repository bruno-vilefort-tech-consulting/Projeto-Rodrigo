<task>
    <type>feature</type>

    <problema_reportado>
      <descricao>
        O chatbot ativado por palavra-chave funciona apenas com correspondência EXATA.
        Não existe opção para escolher entre "Exata" ou "Contém".
      </descricao>
      <comportamento_atual>
        - Teste manual: Funciona quando o usuário digita EXATAMENTE a palavra cadastrada
        - ADS/Campanhas: Falha quando a mensagem contém texto adicional além da palavra-chave
      </comportamento_atual>
      <causa_raiz>
        A lógica de matching em wbotMessageListener.ts:3672,3727,3768 usa comparação estrita (===)
        sem opção de matching parcial (includes/contains)
      </causa_raiz>
    </problema_reportado>

    <scope>
      <backend>
        <routes>
          - /flowcampaign (POST, GET, PUT, DELETE)
          - /flowbuilder (relacionado)
          - /flowdefault (relacionado - flowIdNotPhrase)
        </routes>
        <controllers>
          - FlowCampaignController (store, update)
        </controllers>
        <services>
          - WbotServices/wbotMessageListener.ts (handleMessage função)
          - FlowCampaignService/CreateFlowCampaignService
          - FlowCampaignService/UpdateFlowCampaignService
        </services>
        <models>
          - FlowCampaign (adicionar campo matchType)
        </models>
        <migrations>
          - Nova migration: add-matchType-to-FlowCampaigns
        </migrations>
      </backend>

      <frontend>
        <pages>
          - CampaignsPhrase (listagem)
        </pages>
        <components>
          - CampaignModalPhrase (formulário de criação/edição)
        </components>
        <translations>
          - pt.js, en.js, es.js, tr.js, ar.js (adicionar labels do matchType)
        </translations>
      </frontend>
    </scope>

    <requirements>
      <funcional>
        1. Adicionar campo matchType ao modelo FlowCampaign com opções: "exact" | "contains"
        2. Implementar lógica de matching com suporte a:
           - "exact": Comparação exata (atual) - phrase === body
           - "contains": Comparação parcial - body.includes(phrase) ou body.toLowerCase().includes(phrase.toLowerCase())
        3. Interface do usuário deve permitir selecionar entre "Exata" e "Contém"
        4. Valor padrão para campanhas existentes: "exact" (manter comportamento atual)
        5. Valor padrão para novas campanhas: "contains" (resolver problema de ADS)
      </funcional>

      <tecnico>
        1. Migration deve incluir UP e DOWN com valor default "exact"
        2. Atualizar validação Yup nos services (opcional: enum)
        3. Case-insensitive opcional para modo "contains"
        4. Filtrar por companyId (multi-tenancy)
        5. Emitir Socket.IO event após alteração
      </tecnico>

      <ux>
        1. Radio button ou Select para escolher tipo de matching
        2. Tooltip explicativo da diferença entre "Exata" e "Contém"
        3. Manter Material-UI v5 para novo componente de seleção
        4. Validar campo obrigatório no frontend
      </ux>
    </requirements>


    <implementation_plan>
      <etapa_1>
        <titulo>Criar migration para adicionar campo matchType</titulo>
        <arquivo>backend/src/database/migrations/YYYYMMDDHHMMSS-add-matchType-to-FlowCampaigns.ts</arquivo>
        <detalhes>
          - Adicionar coluna matchType VARCHAR(20) DEFAULT 'exact'
          - Valores permitidos: 'exact' | 'contains'
          - Migration DOWN: remover coluna
          - Testar UP e DOWN antes de commit
        </detalhes>
      </etapa_1>

      <etapa_2>
        <titulo>Atualizar modelo FlowCampaign</titulo>
        <arquivo>backend/src/models/FlowCampaign.ts</arquivo>
        <detalhes>
          - Adicionar campo matchType: string com @Column
          - Opcional: validação de enum no Sequelize
        </detalhes>
      </etapa_2>

      <etapa_3>
        <titulo>Atualizar Services de FlowCampaign</titulo>
        <arquivos>
          - backend/src/services/FlowCampaignService/CreateFlowCampaignService.ts
          - backend/src/services/FlowCampaignService/UpdateFlowCampaignService.ts
        </arquivos>
        <detalhes>
          - Adicionar matchType no schema Yup (opcional)
          - Valor default "contains" para novas campanhas
          - Incluir matchType no create/update
        </detalhes>
      </etapa_3>

      <etapa_4>
        <titulo>Implementar lógica de matching inteligente</titulo>
        <arquivo>backend/src/services/WbotServices/wbotMessageListener.ts</arquivo>
        <detalhes>
          Substituir:
          ```typescript
          listPhrase.filter(item => item.phrase === body)
          ```

          Por função helper:
          ```typescript
          const matchPhrase = (phrase: string, body: string, matchType: string): boolean => {
            if (matchType === 'exact') {
              return phrase === body;
            } else if (matchType === 'contains') {
              return body.toLowerCase().includes(phrase.toLowerCase());
            }
            return false;
          };

          listPhrase.filter(item => matchPhrase(item.phrase, body, item.matchType || 'exact'))
          ```

          Atualizar linhas: 3672, 3727, 3768
        </detalhes>
      </etapa_4>

      <etapa_5>
        <titulo>Atualizar Controller</titulo>
        <arquivo>backend/src/controllers/FlowCampaignController.ts</arquivo>
        <detalhes>
          - Adicionar matchType nos métodos store e update
          - Extrair do req.body
        </detalhes>
      </etapa_5>

      <etapa_6>
        <titulo>Adicionar campo matchType no formulário frontend</titulo>
        <arquivo>frontend/src/components/CampaignModalPhrase/index.js</arquivo>
        <detalhes>
          - Adicionar state: matchType com default "contains"
          - Radio buttons ou Select (Material-UI v5) com opções:
            * "exact" → "Correspondência Exata"
            * "contains" → "Contém a palavra"
          - Tooltip explicativo
          - Incluir matchType no POST/PUT (linhas 233-251)
          - Carregar matchType ao editar (linha 129-142)
        </detalhes>
      </etapa_6>

      <etapa_7>
        <titulo>Adicionar traduções i18n</titulo>
        <arquivos>
          - frontend/src/translate/languages/pt.js
          - frontend/src/translate/languages/en.js
          - frontend/src/translate/languages/es.js
          - frontend/src/translate/languages/tr.js
          - frontend/src/translate/languages/ar.js
        </arquivos>
        <detalhes>
          Adicionar chaves em campaignsPhrase.modal:
          - matchTypeLabel: "Tipo de correspondência"
          - matchTypeExact: "Correspondência Exata"
          - matchTypeContains: "Contém a palavra"
          - matchTypeTooltip: "Exata: mensagem deve ser igual à palavra. Contém: palavra pode aparecer em qualquer parte da
  mensagem"
        </detalhes>
      </etapa_7>

      <etapa_8>
        <titulo>Executar migration e testar</titulo>
        <comandos>
          - npm run db:migrate (backend)
          - Verificar coluna matchType na tabela FlowCampaigns
          - Testar criação de campanha com matchType "contains"
          - Testar matching com mensagem de ADS
          - Validar comportamento case-insensitive
        </comandos>
      </etapa_8>

      <etapa_9>
        <titulo>Commit semântico e documentação</titulo>
        <commit>
          feat(flowcampaign): adicionar opção de matching "Exata" ou "Contém"

          - Adiciona campo matchType ao modelo FlowCampaign
          - Implementa lógica case-insensitive para modo "contains"
          - Adiciona seleção de matchType no formulário de campanhas
          - Resolve problema de ativação via ADS/campanhas
          - Traduzido para 5 idiomas (pt, en, es, tr, ar)

          BREAKING CHANGE: Campanhas existentes mantêm matchType="exact"
          Novas campanhas usam matchType="contains" por padrão
        </commit>
      </etapa_9>
    </implementation_plan>

    <testes_validacao>
      <teste_1>
        <titulo>Matching exato (comportamento atual)</titulo>
        <passos>
          1. Criar campanha com phrase="OLÁ" e matchType="exact"
          2. Enviar mensagem "OLÁ" → deve ativar
          3. Enviar mensagem "Olá mundo" → NÃO deve ativar
          4. Enviar mensagem "olá" → NÃO deve ativar (case-sensitive)
        </passos>
      </teste_1>

      <teste_2>
        <titulo>Matching contém (novo comportamento)</titulo>
        <passos>
          1. Criar campanha com phrase="DESCONTO" e matchType="contains"
          2. Enviar mensagem "DESCONTO" → deve ativar
          3. Enviar mensagem "Olá, quero DESCONTO de 20%" → deve ativar
          4. Enviar mensagem "desconto especial" → deve ativar (case-insensitive)
          5. Enviar mensagem de ADS com texto+palavra → deve ativar
        </passos>
      </teste_2>

      <teste_3>
        <titulo>Retrocompatibilidade</titulo>
        <passos>
          1. Campanhas criadas ANTES da migration devem ter matchType="exact"
          2. Comportamento deve permanecer igual ao anterior
          3. Editar campanha antiga e mudar para "contains" deve funcionar
        </passos>
      </teste_3>

      <teste_4>
        <titulo>Multi-tenancy</titulo>
        <passos>
          1. Empresa A: campanha com phrase="OI"
          2. Empresa B: campanha com phrase="OI"
          3. Mensagem na empresa A não deve disparar campanha da empresa B
          4. Verificar filtro por companyId + whatsappId
        </passos>
      </teste_4>
    </testes_validacao>

    <consideracoes_tecnicas>
      <performance>
        - body.includes() é O(n) mas aceitável para strings curtas
        - toLowerCase() adiciona overhead mínimo
        - Considerar index em (companyId, whatsappId, status) para query
      </performance>

      <seguranca>
        - Sanitizar phrase para evitar regex injection (se usar regex no futuro)
        - Validar matchType no backend (enum)
        - Filtrar sempre por companyId (multi-tenant)
      </seguranca>

      <edge_cases>
        - Phrase vazia: validar no frontend e backend
        - Phrase com espaços: trim() antes de comparar
        - Emojis e caracteres especiais: testar comportamento
        - Mensagens muito longas: limite razoável de caracteres
      </edge_cases>

      <futuras_melhorias>
        - Regex matching (matchType="regex")
        - Múltiplas palavras-chave por campanha
        - Prioridade entre campanhas (se múltiplas darem match)
        - Estatísticas de matching (quantas vezes ativou)
      </futuras_melhorias>
    </consideracoes_tecnicas>

    <exemplo_codigo>
      <migration>
        ```typescript
        // backend/src/database/migrations/YYYYMMDDHHMMSS-add-matchType-to-FlowCampaigns.ts
        import { QueryInterface, DataTypes } from "sequelize";

        module.exports = {
          up: (queryInterface: QueryInterface) => {
            return queryInterface.addColumn("FlowCampaigns", "matchType", {
              type: DataTypes.STRING(20),
              allowNull: false,
              defaultValue: "exact"
            });
          },

          down: (queryInterface: QueryInterface) => {
            return queryInterface.removeColumn("FlowCampaigns", "matchType");
          }
        };
        ```
      </migration>

      <matching_logic>
        ```typescript
        // backend/src/services/WbotServices/wbotMessageListener.ts

        // Helper function (adicionar no início do arquivo)
        const matchPhrase = (phrase: string, body: string, matchType: string = 'exact'): boolean => {
          const normalizedPhrase = phrase.trim();
          const normalizedBody = body.trim();

          if (matchType === 'exact') {
            return normalizedPhrase === normalizedBody;
          } else if (matchType === 'contains') {
            return normalizedBody.toLowerCase().includes(normalizedPhrase.toLowerCase());
          }

          return false;
        };

        // Substituir em 3 locais (linhas 3672, 3727, 3768):
        // ANTES:
        listPhrase.filter(item => item.phrase === body)

        // DEPOIS:
        listPhrase.filter(item => matchPhrase(item.phrase, body, item.matchType))
        ```
      </matching_logic>

      <frontend_form>
        ```jsx
        // frontend/src/components/CampaignModalPhrase/index.js

        // Adicionar state (após linha 85):
        const [matchType, setMatchType] = useState("contains");

        // Carregar ao editar (dentro de detailsPhrase, após linha 133):
        setMatchType(res.data.details.matchType || "exact");

        // Adicionar no formulário (após linha 405):
        <Stack gap={1}>
          <Typography>{i18n.t("campaignsPhrase.modal.matchTypeLabel")}</Typography>
          <RadioGroup
            value={matchType}
            onChange={(e) => setMatchType(e.target.value)}
          >
            <FormControlLabel
              value="exact"
              control={<Radio />}
              label={i18n.t("campaignsPhrase.modal.matchTypeExact")}
            />
            <FormControlLabel
              value="contains"
              control={<Radio />}
              label={i18n.t("campaignsPhrase.modal.matchTypeContains")}
            />
          </RadioGroup>
          <Typography variant="caption" color="textSecondary">
            {i18n.t("campaignsPhrase.modal.matchTypeTooltip")}
          </Typography>
        </Stack>

        // Incluir no save (linha 246):
        api.post("/flowcampaign", {
          name: dataItem.name,
          flowId: idFlow,
          whatsappId: whatsappId,
          phrase: dataItem.phrase,
          matchType: matchType  // ← ADICIONAR
        });
        ```
      </frontend_form>
    </exemplo_codigo>

    <socket_io_events>
      <evento>flowcampaign-update</evento>
      <namespace>/workspace-{companyId}</namespace>
      <payload>
        {
          action: "update",
          flowCampaign: { id, name, phrase, matchType, ... }
        }
      </payload>
      <quando_emitir>Após create/update em FlowCampaignService</quando_emitir>
    </socket_io_events>
  </task>